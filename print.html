<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Gobba Programming Language Handbook</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="expanded "><a href="install.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="expanded "><a href="basics/index.html"><strong aria-hidden="true">3.</strong> The Basics</a></li><li><ol class="section"><li class="expanded "><a href="basics/purity.html"><strong aria-hidden="true">3.1.</strong> Purity and IO</a></li></ol></li><li class="expanded "><a href="stdlib.html"><strong aria-hidden="true">4.</strong> The Standard Library</a></li><li class="expanded "><a href="ocaml.html"><strong aria-hidden="true">5.</strong> Calling Gobba from OCaml</a></li><li class="expanded "><a href="internals/index.html"><strong aria-hidden="true">6.</strong> Internals</a></li><li><ol class="section"><li class="expanded "><a href="internals/grammar.html"><strong aria-hidden="true">6.1.</strong> Grammar</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Gobba Programming Language Handbook</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#welcome-to-the-gobba-programming-language-handbook" id="welcome-to-the-gobba-programming-language-handbook">Welcome to the Gobba Programming Language Handbook</a></h1>
<h1><a class="header" href="#p-aligncenterimg-altgobba-srcgobbapng-width--25-p" id="p-aligncenterimg-altgobba-srcgobbapng-width--25-p"><p align="center"><img alt="gobba" src="gobba.png" width = 25% /></p></a></h1>
<hr />
<p><strong>gobba</strong> is a dynamically typed and purely functional interpreted programming
language, heavily inspired from the OCaml, Haskell and Scheme languages. It is
based on Professors Gianluigi Ferrari and Francesca Levi's
<a href="http://pages.di.unipi.it/levi/codice-18/evalFunEnvFull.ml">minicaml</a>
interpreter example. The goal for gobba is to be a practical language with built
in support for scientific computing, solving some of the problems that exist in
other dynamically typed interpreted languages like python and Javascript.  A
primary goal is also to offer a compromise between solidity, ease of learning
and the ability to express ideas quickly in the language.</p>
<h2><a class="header" href="#features" id="features">Features</a></h2>
<ul>
<li>C and Haskell-like syntax with lexical scoping</li>
<li>Only immutable variables</li>
<li>Dynamically typed</li>
<li>Eager (default) and lazy evaluation</li>
<li>Simple but effective module system</li>
<li>Interactive REPL with readline-like features such as completion, search and hints</li>
<li>The REPL has didactical debugging option to print expression ASTs and every reduction step.</li>
<li>Static inference to separate pure and impure computations</li>
<li>A lot more coming in the next releases...</li>
</ul>
<h2><a class="header" href="#thanks-to" id="thanks-to">Thanks to</a></h2>
<ul>
<li>Prof. Gian-Luigi Ferrari and Francesca Levi for teaching us how to project and develop interpreters in OCaml</li>
<li>Kevin Fontanari for the pixel art gobba mascotte.</li>
<li>Antonio DeLucreziis for helping me implement lazy evaluation.</li>
<li>Prof. Alessandro Berarducci for helping me study lambda calculus in deep.</li>
<li>Giorgio Mossa for helping me polish the lambda-closure mechanism.</li>
</ul>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>To install, you need to have <code>opam</code> (OCaml's package manager with a version greater than 2.0) and a recent OCaml
distribution installed on your system.
You can install <strong>gobba</strong> by running</p>
<pre><code class="language-bash">opam install gobba
</code></pre>
<h3><a class="header" href="#manual-installation" id="manual-installation">Manual installation</a></h3>
<pre><code class="language-bash"># clone the repository
git clone https://github.com/0x0f0f0f/gobba
# cd into it
cd gobba
# install dependencies
opam install dune menhir ANSITerminal cmdliner alcotest bisect_ppx ocamline
# compile
make
# test
make test
# run
make run
# rlwrap is suggested
rlwrap make run
# you can install gobba with
make install
# run again
rlwrap gobba
</code></pre>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>The executable name is <code>gobba</code>. If a file is specified as the first command
line argument, then it will be run as a program. If you are running a program you may want to use the flag <code>-p</code> to print the results of the expressions that are evaluated. Otherwise, if a program is not specified a REPL session will
be opened.</p>
<p>Keep in mind that <strong>gobba</strong> is purely functional and values
are immutable by default!</p>
<h3><a class="header" href="#command-line-options" id="command-line-options">Command Line Options</a></h3>
<ul>
<li>
<p><code>--help[=FMT] (default=auto)</code>:
Show this help in format FMT. The value FMT must be one of <code>auto</code>,
<code>pager</code>, <code>groff</code> or <code>plain</code>. With <code>auto', the format is </code>pager<code>or
   </code>plain' whenever the TERM env var is `dumb' or undefined.</p>
</li>
<li>
<p><code>--internals</code>:
To print or not the language's internal stack traces</p>
</li>
<li>
<p><code>-m MAXSTACKDEPTH, --maxstackdepth=MAXSTACKDEPTH (absent=10)</code>:
The maximum level of nested expressions to print in a stack trace.</p>
</li>
<li>
<p><code>-p, --printexprs</code>:
If set, print the result of expressions when evaluating a program
from file</p>
</li>
<li>
<p><code>-v VERBOSITY, --verbose=VERBOSITY (absent=0)</code>:
If 1, Print AST to stderr after expressions are entered in the
REPL. If 2, also print reduction steps</p>
</li>
<li>
<p><code>--version</code>
Show version information.</p>
</li>
</ul>
<h1><a class="header" href="#the-gobba-programming-language-basics" id="the-gobba-programming-language-basics">The Gobba Programming Language Basics</a></h1>
<h2><a class="header" href="#comments" id="comments">Comments</a></h2>
<p>Comments are treated by gobba as whitespace and consequently ignored. Comments
can be nested and are multi-line by default, and can be written as following:</p>
<pre><code class="language-gobba">(* This is a comment *)
</code></pre>
<h2><a class="header" href="#numbers-arithmetics-and-the-numerical-tower" id="numbers-arithmetics-and-the-numerical-tower">Numbers, Arithmetics and the Numerical Tower</a></h2>
<p>Gobba supports 3 kinds of numbers: integers, floats and complex numbers.
Floating point numbers' decimal part can be omitted if it is 0. Floats also
support the scientific notation in literal values. Complex numbers literals are
&quot;allocated&quot; from other two numbers with the <code>:+</code> operator. The number
on the left will be the real part and the one on the right will be allocated as
the imaginary part.</p>
<pre><code class="language-gobba">(* Integer literals *)
1 ;
0 ;
10350156 ;
(* Floating Point Literals *)
1.2e-3 ;
0.0 ;
0.123 ;
34. ;
4.3e9 ;
(* Complex Number Literals *)
12.1 :+ 1.23;
0 :+ 1.12;
</code></pre>
<p>Arithmetical operations are straightforward. If an arithmetical operation
is called on different types of numbers, the result is &quot;raised&quot; to the &quot;most inclusive&quot; type of numbers.
For example, Integer division returns an integer if the modulo is 0, and returns a float
otherwise.
Floating point numbers can use the power syntax using <code>e</code>.</p>
<pre><code class="language-gobba">(* Addition, multiplication and subtraction *)
1 + 2 + 3 * (4 - 1) ;
(* *)
1. / 2.315 ;
</code></pre>
<h2><a class="header" href="#boolean-literals-and-arithmetic" id="boolean-literals-and-arithmetic">Boolean literals and arithmetic</a></h2>
<p>The boolean literals in gobba are <code>true</code> and <code>false</code>. There are also operators
for the logical AND and OR: <code>&amp;&amp;</code> and <code>||</code>. The comparison operators return
boolean values and are:</p>
<ul>
<li><code>a = b</code>: True if and only if the two objects are the same</li>
<li><code>a &gt; b</code> and <code>a &gt;= b</code>: Greater and greater or equal</li>
<li><code>a &lt; b</code> and <code>a &lt;= b</code>: Less and less or equal</li>
</ul>
<p>Here's an example:</p>
<pre><code class="language-gobba">true &amp;&amp; false || (1 &lt; 2) &amp;&amp; (1 = 1) ;
</code></pre>
<h2><a class="header" href="#character-literals" id="character-literals">Character literals.</a></h2>
<p>The same as all the other languages: Single characters enclosed in <code>'</code> are character literals,
such as <code>'a'</code> or <code>'\n'</code>. UTF-8 support is planned for a future release.</p>
<h2><a class="header" href="#strings" id="strings">Strings</a></h2>
<p>Strings are values enclosed in double quotation marks.
Here is how to concatenate strings</p>
<pre><code class="language-gobba">&quot;hello &quot; ++ &quot;world&quot;
(* It is the same as *)
String:concat &quot;hello &quot; &quot;world&quot;
</code></pre>
<p>To convert any value to a string you can use the <code>show</code> primitive.</p>
<h2><a class="header" href="#lists" id="lists">Lists</a></h2>
<p>Lists are enclosed in square brackets and values are separated by commas.
Lists are heterogeneous, so any value in a list can have a different type from
the other elements of the list.</p>
<pre><code class="language-gobba">[1, 2, &quot;ciao&quot;, 4, 5] ;
</code></pre>
<p><code>::</code> is the classic <code>cons</code> operator. It inserts the element on the left at the beginning of the list.
This is done in <code>O(1)</code> time.
The <code>++</code> operator is used for list and string concatenation.</p>
<pre><code class="language-haskell">1 :: [2] ++ [3]
</code></pre>
<p>To access the n-th value of a list, use the <code>@</code> operator, called &quot;at&quot;. List indexes begin from 0.</p>
<pre><code class="language-gobba">[1, 2, 3, 4] @ 0 (* =&gt; 1 *)
[1, 2, 3, 4] @ 2 (* =&gt; 3 *)
</code></pre>
<p>In gobba, the classic functional programming functions and morphisms on lists
are defined in the <code>List</code> module:</p>
<p>Get the length of a list (done in <code>O(n)</code> time).</p>
<pre><code class="language-gobba">List:length [1, 2, 3, 4] ;
</code></pre>
<p>Get the element at the beginning of a list</p>
<pre><code class="language-gobba">List:head [1, 2, 3, 4] ;
</code></pre>
<p>Get another list with the first element removed</p>
<pre><code class="language-gobba">List:tail [1, 2, 3, 4] ;
</code></pre>
<p>Iterate a function over every list value and return a new list</p>
<pre><code class="language-gobba">List:map (fun x -&gt; x + 1) [1, 2, 3, 4] ;
</code></pre>
<p>List folding: see the <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia Page</a></p>
<pre><code class="language-gobba">List:foldl (fun x y -&gt; x - y) 10 [1, 2, 3, 4] ;
List:foldr (fun x y -&gt; x - y) 10 [1, 2, 3, 4] ;
</code></pre>
<h2><a class="header" href="#declarations" id="declarations">Declarations</a></h2>
<p>Local declaration statements are purely functional and straightforward:</p>
<pre><code class="language-gobba">let x = 4 and y = 1 in x + y
</code></pre>
<p>Global declaration statements create new, purely functional environments in both
programs and the REPL. Omitting <code>in</code> is syntax-sugar, subsequent blocks will
be evaluated in the resulting new environment.</p>
<pre><code class="language-gobba">let a = 2 ;
a + 3 ;
</code></pre>
<p>You can declare <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazily evaluated</a>
variables by prefixing the name of the variables with the <code>lazy</code> keyword.</p>
<pre><code class="language-gobba">let x = 2 and lazy y = (3 + 4) ;
</code></pre>
<h2><a class="header" href="#toplevel-directives" id="toplevel-directives">Toplevel Directives</a></h2>
<p>Toplevel directives can be used in both files and the REPL. Like in OCaml, they
start with a <code>#</code> symbol. Note that toplevel directives are not expressions and
they can only be used in a file (or REPL) top level, and cannot be used inside expressions.</p>
<p><code>#include</code> loads a file at a position relative to the current directory (if in
the REPL) or the directory containing the current running file (in file mode).
The declarations in the included file will be included in the current toplevel environment:</p>
<pre><code class="language-gobba">#include &quot;examples/fibonacci.mini&quot; ;
</code></pre>
<p><code>#module</code> loads a file like <code>#include</code> but the declarations in the included file
will be wrapped in a dictionary, that acts as a module:</p>
<pre><code class="language-gobba">#module &quot;examples/fibonacci.mini&quot; ;
(* Declarations will be available in module *) Fibonacci
</code></pre>
<ul>
<li><code>#verbosity n</code> sets verbosity level to <code>n</code>. There are &quot;unit&quot; directives:</li>
<li><code>#dumpenv ()</code> and <code>#dumppurityenv ()</code> dump the current environments.</li>
<li><code>#pure ()</code>, <code>#impure ()</code> and <code>#uncertain ()</code> set the globally allowed purity level.</li>
</ul>
<h2><a class="header" href="#functions-and-recursion" id="functions-and-recursion">Functions and recursion</a></h2>
<p>For parsing simplicity, only the OCaml anonymous function style of declaring
functions is supported. The keyword <code>fun</code> is interchangeable with <code>lambda</code>.</p>
<pre><code class="language-gobba">(fun x -&gt; x + 1) 1;
let fib = fun n -&gt; if n &lt; 2 then n else (fib (n - 1)) + fib (n - 2)
</code></pre>
<p>Functions are abstracted into a single parameter chain of functions, and they
can be partially applied:</p>
<pre><code class="language-gobba">(fun x y z -&gt; x + y + z) = (fun x -&gt; fun y -&gt; fun z -&gt; x + y + z) ;
(* result: true - bool - This is true!! *)

let f = (fun x y z -&gt; x + y + z) in f 1 2 3 ;
(* result: 6 - int - Function application *)

let f = (fun x y z -&gt; x + y + z) in f 1 2 ;
(* result: (fun z -&gt; ... ) - fun - Partial application *)
</code></pre>
<h2><a class="header" href="#dictionaries-and-modules" id="dictionaries-and-modules">Dictionaries and modules.</a></h2>
<p>Dictionary (object) values are similar to Javascript objects. The difference
from javascript is that the keys of an existing dictionary are treated as
symbols, and values can be lazy.</p>
<p>You may have noticed that dictionary fields are syntactically similar to the
assignments in <code>let</code> statements. This is because there is a strict approach
towards simplicity in the parsing logic and language syntax. A difference from
<code>let</code> statements, is that values in dictionaries can only access the
lexical scope <strong>outside</strong> of the dictionary.</p>
<pre><code class="language-gobba">let n = {hola = 1, lazy mondo = 2, somefunc = fun x -&gt; x + 1 } ;
let m = Dict:insert &quot;newkey&quot; 123 n ;
m = {newkey = 123, hola = 1, mondo = 2, somefunc = fun x -&gt; x + 1 } (* =&gt; true *)
Dict:haskey &quot;newkey&quot; m (* =&gt; true *)
(* =&gt; {newkey = 124, hola = 2, mondo = 3} *)
</code></pre>
<p>An element of a dictionary can be accessed using the <code>:</code> infix operator.</p>
<pre><code class="language-gobba">m:hola (* returns 1 *)
</code></pre>
<p>Some morphisms are defined in the <code>Dict</code> module.</p>
<pre><code class="language-gobba">Dict:map (fun x -&gt; x + 1) m;
Dict:foldl (fun x y -&gt; x + y) 0 m;
Dict:foldr (fun x y -&gt; x - y) 10 m;
</code></pre>
<h2><a class="header" href="#haskell-like-dollar-syntax" id="haskell-like-dollar-syntax">Haskell-like dollar syntax</a></h2>
<p>Too many parens?</p>
<pre><code class="language-gobba">f (g (h (i 1 2 3)))
</code></pre>
<p>Is equivalent to</p>
<pre><code class="language-haskell">f $ g $ h $ i 1 2 3
</code></pre>
<h2><a class="header" href="#purity-of-gobba-code" id="purity-of-gobba-code">Purity of gobba code</a></h2>
<p>From <a href="https://en.wikipedia.org/wiki/Pure_function">Wikipedia</a>:</p>
<blockquote>
<p>In computer programming, a pure function is a function that has the following properties:
Its return value is the same for the same arguments (no variation with local
static variables, non-local variables, mutable reference arguments or input
streams from I/O devices). Its evaluation has no side effects (no mutation of
local static variables, non-local variables, mutable reference arguments or I/O
streams).</p>
</blockquote>
<p>The gobba interpreter statically infers whether the expressions you run in your
programs are <em>numerical</em>, <em>pure</em> or <em>impure</em>. An impure expression is a
computation that calls primitives that have side effects, such as direct memory
access or I/O access. Pure expressions are those expressions that do not imply
side effects. Numerical expressions are the purest computations that operate
only on numerical values. By default, the interpreter is in a <code>uncertain</code> state,
it means that it will allow evaluation of pure expressions, and will allow
impure code to be executed only if inside an <code>impure</code> statement.</p>
<p>To be <code>impure</code>, an expression must contain an explicit <code>impure</code> statement or a
call to an impure language primitive such as <code>IO:print</code>. You can enforce purity
explicitely, inside an expression by wrapping it into the <code>pure</code> and <code>impure</code>
statements, followed by an expression.</p>
<p>It is good practice to reduce the use of the <code>pure/impure</code> keywords as much as
possible, and to avoid using it inside of function bodies. This means keeping
your code as purely functional as you can.</p>
<p>Here is an example:</p>
<pre><code class="language-gobba">let bad_function = fun x -&gt;
    impure (let mystring =
        &quot;I am a bad impure function! Also: &quot; ++ x in
        IO:print_endline mystring );

let good_function = fun x -&gt;
    IO:print_endline (&quot;I am a good function! Also: &quot; ++ x) ;
</code></pre>
<p>The following function call is causing side effects and will error</p>
<pre><code class="language-gobba">bad_function &quot;hello!&quot; ;
</code></pre>
<p>The above will error, because it is trying to execute
an impure computation in a pure environment</p>
<pre><code class="language-gobba">good_function &quot;hello! I should error&quot; ;
</code></pre>
<p>Here's a good way of calling it</p>
<pre><code class="language-gobba">impure $ good_function &quot;hello!&quot; ;
</code></pre>
<p>You can specify that you DO NOT want to compute impure
expressions by using the pure statement
We want the following to error because it contains an impure computation.</p>
<pre><code class="language-gobba">pure $ good_function &quot;henlo world! I should error&quot; ;
</code></pre>
<p>The above will error because a pure contest
does not allow nesting an impure contest inside</p>
<pre><code class="language-gobba">pure $ bad_function &quot;ciao mondo! I should error&quot; ;
</code></pre>
<p>A good way of structuring your code is keeping <code>pure/impure</code> statements as
external from expressions as you can (towards the top level).</p>
<h2><a class="header" href="#sequencing--operator" id="sequencing--operator">Sequencing (&gt;&gt;) operator</a></h2>
<p>Keep in mind that every expression is either numerical, pure or impure.
You may like, as in imperative languages, to do operations sequentially one after another.
Newcomers may be confused by the <code>;</code> symbol at the end of expressions. This special symbol signals gobba that the current command is over, and everything after <code>;</code> is another command.
A command is either a global declaration, a directive call or an expression to be evaluated.
You may want to sequence operations inside of expressions. To do so, you can use the <code>&gt;&gt;</code> operator.
The <code>&gt;&gt;</code> operator is called <em>the sequencing operator</em> or the <em>then</em> operator and what it does is straightforward:</p>
<blockquote>
<p>Evaluate the expression on the left, discard the result and <strong>then</strong> evaluate the expression on the right.</p>
</blockquote>
<p>Here's a simple example: since 12.4 is greater than 3, this snippet of code will
print &quot;Good maths!&quot; on the standard output, and then (<code>&gt;&gt;</code>) the variable <code>c</code>
will be assigned to <code>a * c</code>, precisely <code>37.2</code>.</p>
<pre><code class="language-gobba">let a = 12.4 and b = 3 ;
let c =
    if a &lt; b then
        impure $ IO:print_endline &quot;Bad maths!&quot; &gt;&gt;
        a + b
    else
        impure $ IO:print_endline &quot;Good maths!&quot; &gt;&gt;
        a * b ;
</code></pre>
<h2><a class="header" href="#function-pipes-reverse-composition-and-composition" id="function-pipes-reverse-composition-and-composition">Function pipes (reverse composition) and composition</a></h2>
<p>You can redirect the result of a function to the first argument of another
function using the <code>&gt;=&gt;</code> operator. The <code>&lt;=&lt;</code> operator does the same thing but in reverse.
The following example will output 6, because 2 + 3 is piped into z + 1</p>
<pre><code class="language-gobba">let sum_and_add_one = (fun x y -&gt; x + y) &gt;=&gt; (fun z -&gt; z + 1) ;
sum_and_add_one 2 3
</code></pre>
<p>The composition operators yield the same result as normal function composition:</p>
<pre><code class="language-gobba">let my_sum = (fun x y -&gt; x + y) ;
let add_one = (fun z -&gt; z + 1) ;
(add_one &lt;=&lt; my_sum) 2 3 = add_one (my_sum 2 3) ;
</code></pre>
<p>The operator <code>&lt;=&lt;</code> means <em>compose</em>, the following example evaluates to true:</p>
<pre><code class="language-gobba">(add_one &lt;=&lt; my_sum) = (my_sum &gt;=&gt; add_one) ;
</code></pre>
<h1><a class="header" href="#the-gobba-standard-library" id="the-gobba-standard-library">The Gobba Standard Library</a></h1>
<p>This chapter is a work in progress.</p>
<p>Most standard library functions are organized in modules. The main modules are</p>
<ul>
<li><code>IO</code>: All the impure Input/Output functionality is contained in this module.</li>
<li><code>Char</code>: Common operations on characters.</li>
<li><code>List</code>: Simple and higher-order functions to manipulate lists.</li>
<li><code>Dict</code>: Simple and higher-order operations on dictionaries.</li>
<li><code>String</code>:  Common string operations.</li>
</ul>
<p>Some other basic primitives are defined on the toplevel, those are:</p>
<ul>
<li><code>show val</code>: Gives you a string representation of any value.</li>
<li><code>typeof val</code>: Gives you the string representation of the type of a value.</li>
<li><code>failwith message</code>: Fail the current computation with an error message</li>
</ul>
<h2><a class="header" href="#primitives-and-printing" id="primitives-and-printing">Primitives and printing</a></h2>
<p>The impure primitives <code>IO:print</code> and <code>IO:print_endline</code> automatically call <code>show</code> on a
value. The difference between them is that <code>IO:print_endline</code> automatically adds a
newline at the end of the line.</p>
<h1><a class="header" href="#calling-gobba-from-your-ocaml-programs" id="calling-gobba-from-your-ocaml-programs">Calling gobba from your OCaml programs</a></h1>
<p>You may want to use gobba as an embedded language in your OCaml projects. Just
add gobba as a dependency and you can call gobba code from OCaml fairly easily.
Keep in mind that <strong>gobba</strong> is dynamically typed and if you want to do something
with the results of gobba evaluation you will have to extract the values with
the unpacking functions.</p>
<pre><code class="language-ocaml">(* This not code written in gobba, this is written in OCaml *)
(* Run a gobba string and retrieve the value and resulting state *)
let x, state = Gobba.Repl.run_string &quot;3.14 * (4.0001)&quot; () in
(* The expression is not altering the state, so let's throw it away *)
let _ = state and extracted_value = Gobba.Typecheck.unpack_float x in
print_float extracted_value
</code></pre>
<h1><a class="header" href="#internals-of-the-gobba-programming-language" id="internals-of-the-gobba-programming-language">Internals of the Gobba programming language.</a></h1>
<h2><a class="header" href="#interactive-command-line-interface" id="interactive-command-line-interface">Interactive Command Line Interface</a></h2>
<p>If no filename is passed to <code>gobba</code> executable, the interactive shell interface is launched. The REPL shell is built upon a simple library called <a href="https://github.com/chrisnevers/ocamline">ocamline</a>, which itself relies on a library called <a href="https://github.com/ocaml-community/ocaml-linenoise">ocaml-linenoise</a> that provides <code>readline</code> navigation and completion functionality without additional system dependencies.</p>
<h2><a class="header" href="#syntax-and-parser" id="syntax-and-parser">Syntax and Parser</a></h2>
<p>Lexing is achieved with <code>ocamllex</code>, the default tool for generating scanners in OCaml. The parser is realized with the <a href="http://gallium.inria.fr/%7Efpottier/menhir/">Menhir</a> parser generator library, and is documented using <strong>Obelisk</strong>, which generates a clean text file containing the language grammar, available in Appendix [grammar].</p>
<h2><a class="header" href="#purity-inference" id="purity-inference">Purity Inference</a></h2>
<p>An important feature of the gobba language is the purity inference algorithm, which is performed statically on expressions before evaluation. It is an interpretation of expressions over the domain of purity, meant to prevent side effects by signal an error if they are contained inside the programs written in the language. Expressions are tagged by the algorithm with the <code>Pure</code>, <code>Impure</code> and <code>Numerical</code> labels. An <code>Impure</code> expression is an expression that contains calls to primitives that perform I/O operations, mutable variables and/or imperative style assignments. A <code>Numerical</code> expression is an expression where only numerical operations are performed; <code>Pure</code> expressions are those which do not fall into the previous two categories.</p>
<p>To achieve the execution of impure side effects, the programmer has two constructs available called <strong>purity blocks</strong>. By default, the evaluator is in an <code>Uncertain</code> context, which means that it will not allow side effects to be carried on by evaluation, but will allow evaluating purity blocks that change the currently allowed purity context. The <code>impure</code> statement takes an expression (the block) and evaluates it in a context where the allowed purity is <code>Impure</code>, so that side effects may be performed. The other construct available, the <code>pure</code> statement, takes an expression and enforces a <code>Pure</code> context, meaning that side effects and nested impure blocks will not be allowed inside of the expression.</p>
<h2><a class="header" href="#ast-optimization" id="ast-optimization">AST Optimization</a></h2>
<p>After purity inference is performed, and before evaluation, AST expressions are analyzed and optimized by an optimizer function that is recursively called over the tree that is representing the expression. The optimizer simplifies expressions which result is known and therefore does not need to be evaluated. For example, it is known that <code>5 + 3 equiv 8</code> and <code>true &amp;&amp; (true || (false &amp;&amp; false)) equiv true</code>. When a programmer writes a program, she or he may not want to do all the simple calculations before writing the program in which they appear in, we rely on machines to simplify those processes. Reducing constants before evaluation may seem unnecessary when writing a small program, but they do take away computation time, and if they appear inside of loops, it is a wise choice to simplify those constant expressions whose result is already known before it is calculated in all the loop iterations. It is also necessary in optimizing programs before compilation. The optimizer, by now, reduces operations between constants and <code>if</code> statements whose guard is always true (or false). To achieve minimization to an unreducible form, optimizer calls are repeated until it produces an output equal to its input; this way, we get a tree representing an expression that cannot be optimized again. This process is fairly easy:</p>
<pre><code class="language-ocaml">let rec iterate_optimizer e =
  let oe = optimize e in
  if oe = e then e (* Bottoms out *)
  else iterate_optimizer oe
</code></pre>
<p>Boolean operations are reduced using laws from the propositional calculus, such as DeMorgan’s law, complement, absorption and other trivial ones.</p>
<h2><a class="header" href="#types" id="types">Types</a></h2>
<p>TODO </p>
<h2><a class="header" href="#evaluator" id="evaluator">Evaluator</a></h2>
<p><code>gobba</code>’s evaluator is heavily inspired by the Metacircular Evaluator defined in the highly acclaimed textbook <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">Structure and Interpretation of Computer Programs</a>.</p>
<h2><a class="header" href="#primitives" id="primitives">Primitives</a></h2>
<p>The language primitives that are implemented in OCaml are organized in modules separated by functionality. Each primitive is a function that accepts a list of evaluated values and returns a single reduced value; therefore they have a type of <code>evt list -&gt; evt</code>. OCaml primitives have to perform internal typechecking and unpacking of the arguments they receive from the gobba calls.</p>
<p>From the evaluator’s perspective, primitives are organized in a table such that when a symbol gets evaluated, it is looked up in the primitives table, if there is a match then the found primitive’s name is wrapped in an <code>ApplyPrimitive</code> expression nestedinside of a lazy lambda expression that permits partial application. When the evaluator finally encounters an <code>ApplyPrimitive</code> expression, the primitive OCaml function is extracted, applied to the arguments and the resulting value is returned by the current evaluator call. If a primitive is not found when looking up for a symbol, then a symbol lookup is performed in the current environment.</p>
<p>Some primitives, such as catamorphic procedures, are not native OCaml functions but small expressions written directly in gobba; those primitives are kept as lazy expressions into the same table as native OCaml primitives. The key difference between the two resides in the fact that those textual gobba primitives are not transformed into a function which body contains only an <code>ApplyPrimitive</code> call, but are instead parsed and analyzed at run time. The resulting additional startup time caused by parsing and analysis is proportional to the number of textual form primitives in the table and therefore quite irrelevant on non-embedded computer systems. The <em>fold left</em> and <em>fold right</em> catamorphic primitives are written directly in the gobba language and are hereby provided as examples.</p>
<p>This is the fold left procedure defined in the gobba standard library, which is tail recursive:</p>
<pre><code class="language-gobba">fun f z l -&gt;
if typeof l = &quot;list&quot; then
  let aux = fun f z l -&gt;
    if l = [] then z else
      aux f (f z (head l)) (tail l)
    in aux f z l
else if typeof l = &quot;dict&quot; then
    let aux = fun f z kl vl -&gt;
        if kl = [] &amp;&amp; vl = [] then z else
        aux f (f z (head vl)) (tail kl) (tail vl)
    in aux f z (getkeys l) (getvalues l)
else failwith &quot;value is not iterable&quot;
</code></pre>
<p>This is the fold right procedure defined in gobba standard library, which is <em>not</em> tail recursive:</p>
<pre><code class="language-gobba">fun f z l -&gt;
if typeof l = &quot;list&quot; then
   let aux = fun f z l -&gt;
      if l = [] then z else
      f (head l) (aux f z (tail l))
   in aux f z l
else if typeof l = &quot;dict&quot; then
   let aux = fun f z kl vl -&gt;
      if kl = [] &amp;&amp; vl = [] then z else
      f (head vl) (aux f z (tail kl) (tail vl))
   in aux f z (getkeys l) (getvalues l)
else failwith &quot;value is not iterable&quot;
</code></pre>
<h2><a class="header" href="#tests" id="tests">Tests</a></h2>
<p>Unit testing is extensively performed using the alcotest testing framework. Code coverage is provided by the <code>bisect_ppx</code> library which yields an HTML page containing the coverage percentage when unit tests are run by the dune build system. After each commit is pushed to the remote version control repository on Github, the package is built and tests are run thanks to the Travis Continuos Integration system.</p>
<h1><a class="header" href="#grammar" id="grammar">Grammar</a></h1>
<p>This is the full parsing grammar for the gobba language:</p>
<pre><code class="language-bnf">&lt;optterm_list(separator, X)&gt; ::= [separator]
                               | &lt;optterm_nonempty_list(separator, X)&gt;

&lt;optterm_nonempty_list(separator, X)&gt; ::= X [separator]
                                        | X separator
                                          &lt;optterm_nonempty_list(separator,
                                          X)&gt;

&lt;toplevel&gt; ::= &lt;optterm_nonempty_list(SEMI, &lt;statement&gt;)&gt; EOF

&lt;statement&gt; ::= &lt;ast_expr&gt;
              | &lt;def&gt;
              | &lt;directive&gt;

&lt;assignment&gt; ::= SYMBOL EQUAL &lt;ast_expr&gt;
               | LAZY SYMBOL EQUAL &lt;ast_expr&gt;

&lt;def&gt; ::= LET [&lt;assignment&gt; (AND &lt;assignment&gt;)*]

&lt;directive&gt; ::= DIRECTIVE STRING
              | DIRECTIVE INTEGER
              | DIRECTIVE UNIT

&lt;ast_expr&gt; ::= &lt;ast_app_expr&gt;
             | &lt;ast_expr&gt; CONS &lt;ast_expr&gt;
             | NOT &lt;ast_expr&gt;
             | &lt;ast_expr&gt; BIND &lt;ast_expr&gt;
             | &lt;ast_expr&gt; ATSIGN &lt;ast_expr&gt;
             | &lt;ast_expr&gt; CONCAT &lt;ast_expr&gt;
             | &lt;ast_expr&gt; LAND &lt;ast_expr&gt;
             | &lt;ast_expr&gt; OR &lt;ast_expr&gt;
             | &lt;ast_expr&gt; EQUAL &lt;ast_expr&gt;
             | &lt;ast_expr&gt; DIFFER &lt;ast_expr&gt;
             | &lt;ast_expr&gt; GREATER &lt;ast_expr&gt;
             | &lt;ast_expr&gt; LESS &lt;ast_expr&gt;
             | &lt;ast_expr&gt; GREATEREQUAL &lt;ast_expr&gt;
             | &lt;ast_expr&gt; LESSEQUAL &lt;ast_expr&gt;
             | &lt;ast_expr&gt; PLUS &lt;ast_expr&gt;
             | &lt;ast_expr&gt; MINUS &lt;ast_expr&gt;
             | &lt;ast_expr&gt; COMPLEX &lt;ast_expr&gt;
             | &lt;ast_expr&gt; TIMES &lt;ast_expr&gt;
             | &lt;ast_expr&gt; DIV &lt;ast_expr&gt;
             | IF &lt;ast_expr&gt; THEN &lt;ast_expr&gt; ELSE &lt;ast_expr&gt;
             | &lt;def&gt; IN &lt;ast_expr&gt;
             | LAMBDA SYMBOL+ LARROW &lt;ast_expr&gt;
             | &lt;ast_expr&gt; COMPOSE &lt;ast_expr&gt;
             | &lt;ast_expr&gt; PIPE &lt;ast_expr&gt;

&lt;ast_app_expr&gt; ::= &lt;ast_simple_expr&gt;+

&lt;ast_simple_expr&gt; ::= SYMBOL
                    | UNIT
                    | DOLLAR &lt;ast_expr&gt;
                    | LPAREN &lt;ast_expr&gt; RPAREN
                    | &lt;ast_simple_expr&gt; COLON SYMBOL
                    | PURE &lt;ast_expr&gt;
                    | IMPURE &lt;ast_expr&gt;
                    | LSQUARE &lt;optterm_list(COMMA, &lt;ast_expr&gt;)&gt; RSQUARE
                    | LVECT &lt;optterm_nonempty_list(COMMA, &lt;ast_expr&gt;)&gt; RVECT
                    | LVECT RVECT
                    | LBRACKET &lt;optterm_list(COMMA, &lt;assignment&gt;)&gt; RBRACKET
                    | BOOLEAN
                    | CHAR
                    | STRING
                    | INTEGER
                    | FLOAT
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
